/*
 * ESP32 Customer Configuration
 * Organization: {{ORGANIZATION}}
 * Customer ID: {{CUSTOMER_ID}}
 * Application: {{APPLICATION_NAME}}
 * Generated: {{GENERATED_DATE}}
 */

#include <WiFi.h>
#include <ESPAsyncWebServer.h>
#include <ArduinoJson.h>
#include <Wire.h>
#include <Adafruit_SHT31.h>

// USB Host and Serial Communication for CU12
#include <USB.h>
#include <HardwareSerial.h>

// CU12 Protocol Constants (Medical Device Communication)
#define CU12_STX 0x02
#define CU12_ETX 0x03
#define CU12_STATUS_REQUEST 0x80
#define CU12_UNLOCK_SLOT 0x81
#define CU12_GET_VERSION 0x8F
#define CU12_ASK_DEFAULT 0x00
#define CU12_ASK_SUCCESS 0x10
#define CU12_ASK_FAILED 0x11
#define CU12_DEFAULT_ADDR 0x00
#define CU12_BAUD_RATE 19200
#define CU12_MAX_SLOTS 12
#define CU12_PACKET_TIMEOUT 3000
#define CU12_MAX_RETRIES 3

// RS485 Hardware Configuration (Built-in Transceiver)
// MEDICAL DEVICE COMPLIANCE: Half-duplex RS485 communication with CU12
// Connection: ESP32 A+ -> CU12 A, ESP32 B- -> CU12 B, ESP32 GND -> CU12 GND
// CU12 Y/Z pins unused (full-duplex capability not required)
#define RS485_DE_PIN 18        // Direction Enable pin for half-duplex control
#define RS485_RX_PIN 16        // Built-in RS485 RX (connected to A+/B-)
#define RS485_TX_PIN 17        // Built-in RS485 TX (connected to A+/B-)

// Customer Configuration
const char* CUSTOMER_ORG = "{{ORGANIZATION}}";
const char* CUSTOMER_ID = "{{CUSTOMER_ID}}";  
const char* APPLICATION_NAME = "{{APPLICATION_NAME}}";

// SHT30 I2C Sensor Configuration (Using default I2C pins)
Adafruit_SHT31 sht31 = Adafruit_SHT31();

// Sensor status tracking
bool sensorAvailable = false;
String sensorErrorMessage = "";
String sensorMode = "unknown";

// CU12 Hardware Communication (Medical Device)
HardwareSerial CU12Serial(1); // Use UART1 for CU12 communication
bool cu12Available = false;
String cu12ErrorMessage = "";
String cu12Mode = "unknown";
uint8_t cu12SlotStates[CU12_MAX_SLOTS] = {0}; // Track slot states
unsigned long lastCU12Communication = 0;

// ========================================
// MEDICAL DEVICE LOGGING SYSTEM
// ========================================
struct LogEntry {
  unsigned long timestamp;
  String level;
  String component;
  String message;
  String details;
};

const int MAX_LOG_ENTRIES = 50;
LogEntry systemLogs[MAX_LOG_ENTRIES];
int logIndex = 0;
int totalLogCount = 0;

void addSystemLog(String level, String component, String message, String details = "") {
  systemLogs[logIndex] = {millis(), level, component, message, details};
  logIndex = (logIndex + 1) % MAX_LOG_ENTRIES;
  totalLogCount++;
  
  // Also output to Serial for real-time monitoring
  Serial.printf("[%s] %s: %s", level.c_str(), component.c_str(), message.c_str());
  if (details.length() > 0) {
    Serial.printf(" - %s", details.c_str());
  }
  Serial.println();
}

void logCU12Event(String level, String message, String details = "") {
  addSystemLog(level, "CU12", message, details);
}

void logSensorEvent(String level, String message, String details = "") {
  addSystemLog(level, "SHT30", message, details);
}

void logSystemEvent(String level, String message, String details = "") {
  addSystemLog(level, "SYSTEM", message, details);
}

void logNetworkEvent(String level, String message, String details = "") {
  addSystemLog(level, "NETWORK", message, details);
}

// WiFi Access Point Configuration
const char* AP_SSID = "{{WIFI_SSID}}";
const char* AP_PASSWORD = "{{WIFI_PASSWORD}}";
IPAddress local_ip(192, 168, 4, 1);
IPAddress gateway(192, 168, 4, 1);
IPAddress subnet(255, 255, 255, 0);

// Create AsyncWebServer object on port 80
AsyncWebServer server(80);

// CU12 Protocol Functions (Medical Device Communication)
uint8_t calculateCU12Checksum(uint8_t* packet, int length) {
  uint16_t sum = 0;
  for (int i = 0; i < length; i++) {
    sum += packet[i];
  }
  return sum & 0xFF;
}

int buildCU12Packet(uint8_t* buffer, uint8_t addr, uint8_t lockNum, uint8_t cmd, uint8_t ask, uint8_t* data, uint8_t dataLen) {
  buffer[0] = CU12_STX;
  buffer[1] = addr;
  buffer[2] = lockNum;
  buffer[3] = cmd;
  buffer[4] = ask;
  buffer[5] = dataLen;
  buffer[6] = CU12_ETX;
  
  // Calculate checksum (all bytes before SUM position)
  uint8_t checksum = calculateCU12Checksum(buffer, 7);
  buffer[7] = checksum;
  
  // Add data if any
  if (dataLen > 0 && data != nullptr) {
    memcpy(&buffer[8], data, dataLen);
  }
  
  return 8 + dataLen; // Total packet length
}

bool sendCU12Command(uint8_t cmd, uint8_t lockNum = 0x00, uint8_t* data = nullptr, uint8_t dataLen = 0) {
  if (!cu12Available) {
    Serial.println("ERROR: CU12 not available for communication");
    return false;
  }
  
  uint8_t packet[48]; // Maximum packet size
  int packetLen = buildCU12Packet(packet, CU12_DEFAULT_ADDR, lockNum, cmd, CU12_ASK_DEFAULT, data, dataLen);
  
  // Clear receive buffer
  while (CU12Serial.available()) {
    CU12Serial.read();
  }
  
  // MEDICAL DEVICE SAFETY: RS485 Half-duplex Direction Control
  // Critical for preventing bus collisions in medical device communication
  digitalWrite(RS485_DE_PIN, HIGH);  // Enable transmit mode (DE pin HIGH)
  delayMicroseconds(10);             // Hardware switching delay per RS485 spec
  
  // MEDICAL DEVICE SAFETY: Transmit CU12 command packet
  // All medication dispensing commands must be transmitted reliably
  CU12Serial.write(packet, packetLen);
  CU12Serial.flush();                // CRITICAL: Wait for complete transmission
  
  // MEDICAL DEVICE SAFETY: Return to receive mode immediately after transmission
  // Prevents bus conflicts and ensures proper response reception
  delayMicroseconds(10);             // Hardware switching delay per RS485 spec  
  digitalWrite(RS485_DE_PIN, LOW);   // Switch to receive mode (DE pin LOW)
  
  // Log for medical device compliance
  Serial.printf("MEDICAL: CU12 Command sent - CMD: 0x%02X, LOCKNUM: 0x%02X, LEN: %d\n", cmd, lockNum, packetLen);
  
  lastCU12Communication = millis();
  return true;
}

bool readCU12Response(uint8_t* response, int maxLen, int timeoutMs = CU12_PACKET_TIMEOUT) {
  unsigned long startTime = millis();
  int bytesRead = 0;
  
  while (millis() - startTime < timeoutMs && bytesRead < maxLen) {
    if (CU12Serial.available()) {
      response[bytesRead] = CU12Serial.read();
      bytesRead++;
      
      // Check for complete packet (minimum 8 bytes)
      if (bytesRead >= 8 && response[0] == CU12_STX && response[6] == CU12_ETX) {
        uint8_t dataLen = response[5];
        if (bytesRead >= 8 + dataLen) {
          // Verify checksum
          uint8_t expectedChecksum = calculateCU12Checksum(response, 7);
          if (response[7] == expectedChecksum) {
            Serial.printf("MEDICAL: CU12 Response received - ASK: 0x%02X, LEN: %d\n", response[4], bytesRead);
            return true;
          } else {
            Serial.printf("ERROR: CU12 Checksum mismatch - Expected: 0x%02X, Got: 0x%02X\n", expectedChecksum, response[7]);
            return false;
          }
        }
      }
    }
    delay(1);
  }
  
  Serial.printf("ERROR: CU12 Response timeout - Bytes read: %d\n", bytesRead);
  return false;
}

bool initializeCU12() {
  logCU12Event("INFO", "Starting CU12 Hardware Communication initialization");
  
  // Initialize USB Host for ESP32-S3
  logSystemEvent("INFO", "Initializing USB Host for ESP32-S3");
  USB.begin();
  delay(1000);
  
  // Configure RS485 Direction Enable pin for half-duplex communication
  pinMode(RS485_DE_PIN, OUTPUT);
  digitalWrite(RS485_DE_PIN, LOW); // Start in receive mode
  logCU12Event("INFO", "RS485 DE pin configured", "GPIO " + String(RS485_DE_PIN) + " set to receive mode");
  
  // Initialize UART1 for CU12 communication using built-in RS485 transceiver
  // GPIO 16 (RX) and GPIO 17 (TX) are internally connected to RS485 A+/B-
  CU12Serial.begin(CU12_BAUD_RATE, SERIAL_8N1, RS485_RX_PIN, RS485_TX_PIN);
  delay(500);
  
  logCU12Event("INFO", "Built-in RS485 initialized", 
               "RX: GPIO" + String(RS485_RX_PIN) + ", TX: GPIO" + String(RS485_TX_PIN) + ", Baud: " + String(CU12_BAUD_RATE));
  
  // Test CU12 communication with version request
  for (int attempt = 1; attempt <= CU12_MAX_RETRIES; attempt++) {
    logCU12Event("INFO", "Connection attempt " + String(attempt) + "/" + String(CU12_MAX_RETRIES));
    
    if (sendCU12Command(CU12_GET_VERSION)) {
      uint8_t response[48];
      if (readCU12Response(response, sizeof(response))) {
        if (response[4] == CU12_ASK_SUCCESS) {
          cu12Available = true;
          cu12Mode = "live";
          logCU12Event("INFO", "âœ… CU12 Hardware validated and operational", "Version request successful");
          return true;
        } else {
          logCU12Event("WARN", "CU12 responded but with error code", "ASK code: 0x" + String(response[4], HEX));
        }
      } else {
        logCU12Event("WARN", "Failed to read CU12 response", "Attempt " + String(attempt));
      }
    } else {
      logCU12Event("WARN", "Failed to send CU12 command", "Attempt " + String(attempt));
    }
    
    delay(1000);
  }
  
  cu12Available = false;
  cu12Mode = "error";
  cu12ErrorMessage = "CU12 hardware initialization failed after " + String(CU12_MAX_RETRIES) + " attempts";
  logCU12Event("ERROR", "CU12 initialization failed", cu12ErrorMessage);
  return false;
}

void setup() {
  Serial.begin(115200);
  delay(1000); // Allow Serial to initialize
  
  Serial.println();
  Serial.println("========================================");
  Serial.println("SMC ESP32 Customer Configuration");
  Serial.printf("Customer: %s (%s)\n", CUSTOMER_ORG, CUSTOMER_ID);
  Serial.printf("Application: %s\n", APPLICATION_NAME);
  Serial.println("========================================");
  
  // Initialize logging system
  logSystemEvent("INFO", "System startup initiated", "Customer: " + String(CUSTOMER_ORG) + " (" + String(CUSTOMER_ID) + ")");
  logSystemEvent("INFO", "Application: " + String(APPLICATION_NAME));
  
  // Initialize Wi-Fi
  logNetworkEvent("INFO", "Starting WiFi Access Point initialization");
  WiFi.mode(WIFI_AP);
  WiFi.softAPConfig(local_ip, gateway, subnet);
  WiFi.softAP(AP_SSID, AP_PASSWORD);
  
  logNetworkEvent("INFO", "WiFi AP configured", 
                  "SSID: " + String(AP_SSID) + ", IP: " + WiFi.softAPIP().toString());
  logNetworkEvent("INFO", "MAC Address: " + WiFi.macAddress());
  
  // Initialize I2C for SHT30 Sensor - Medical Device Compliance
  logSensorEvent("INFO", "Initializing SHT30 I2C Temperature/Humidity Sensor");
  Wire.begin(); // Use default I2C pins (SDA=21, SCL=22 for ESP32)
  Wire.setClock(100000); // Set I2C clock to 100kHz for stable communication
  logSensorEvent("INFO", "I2C initialized", "Default pins (SDA=21, SCL=22), Clock=100kHz");
  
  // Medical Device Sensor Validation with Retry Logic
  logSensorEvent("INFO", "Starting sensor connectivity test with retry mechanism");
  delay(1000); // Wait for I2C to stabilize
  
  bool sensorInitialized = false;
  int retryCount = 0;
  const int maxRetries = 3;
  
  // Retry loop for medical device reliability
  while (!sensorInitialized && retryCount < maxRetries) {
    retryCount++;
    logSensorEvent("INFO", "Sensor initialization attempt " + String(retryCount) + "/" + String(maxRetries));
    
    if (sht31.begin(0x44)) {
      delay(500); // Allow sensor to stabilize after initialization
      logSensorEvent("INFO", "I2C communication established", "Address: 0x44");
      
      // Perform comprehensive sensor validation
      float temp = sht31.readTemperature();
      float humidity = sht31.readHumidity();
      
      // Medical device range validation (extended for safety)
      if (!isnan(temp) && !isnan(humidity) && 
          temp >= -40.0 && temp <= 85.0 &&     // SHT30 operating range
          humidity >= 0.0 && humidity <= 100.0) {
        
        sensorInitialized = true;
        sensorAvailable = true;
        sensorMode = "live";
        logSensorEvent("INFO", "âœ… SHT30 sensor validated and operational", 
                       "Temp: " + String(temp, 2) + "Â°C, Humidity: " + String(humidity, 2) + "%RH");
        logSensorEvent("INFO", "Sensor status confirmed", "Address: 0x44, Mode: Live, Retry: " + String(retryCount));
      } else {
        sensorErrorMessage = "Sensor reading validation failed - Invalid temperature or humidity values";
        logSensorEvent("WARN", sensorErrorMessage, "Temp: " + String(temp, 2) + ", Humidity: " + String(humidity, 2));
        delay(1000); // Wait before retry
      }
    } else {
      sensorErrorMessage = "I2C communication failed - SHT30 sensor not responding at address 0x44";
      logSensorEvent("WARN", sensorErrorMessage, "Attempt " + String(retryCount));
      delay(1000); // Wait before retry
    }
  }
  
  // Final sensor status determination - NO MOCK DATA
  if (!sensorInitialized) {
    sensorAvailable = false;
    sensorMode = "error";
    if (sensorErrorMessage.isEmpty()) {
      sensorErrorMessage = "SHT30 sensor initialization failed after " + String(maxRetries) + " retry attempts";
    }
    logSensorEvent("ERROR", "Sensor initialization failed", sensorErrorMessage);
    logSensorEvent("WARN", "Hardware validation required - System will return sensor errors");
  }

  // Initialize CU12 Hardware Communication (Medical Device)
  Serial.println("========================================");
  Serial.println("MEDICAL: CU12 Hardware Initialization");
  Serial.println("========================================");
  initializeCU12();

  // Configure CORS
  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Origin", "*");
  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Headers", "*");

  // Root endpoint
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
    String html = "<!DOCTYPE html><html><head><title>SMC ESP32 - " + String(CUSTOMER_ORG) + "</title></head>";
    html += "<body style='font-family: Arial; padding: 20px;'>";
    html += "<h1>SMC Medical Device Configuration</h1>";
    html += "<div style='background: #f0f0f0; padding: 15px; border-radius: 5px;'>";
    html += "<h3>Customer Information</h3>";
    html += "<p><strong>Organization:</strong> " + String(CUSTOMER_ORG) + "</p>";
    html += "<p><strong>Customer ID:</strong> " + String(CUSTOMER_ID) + "</p>";
    html += "<p><strong>Application:</strong> " + String(APPLICATION_NAME) + "</p>";
    html += "<p><strong>MAC Address:</strong> " + WiFi.macAddress() + "</p>";
    html += "</div></body></html>";
    
    request->send(200, "text/html", html);
  });

  // MAC endpoint
  server.on("/mac", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    doc["mac_address"] = WiFi.macAddress();
    doc["customer_id"] = CUSTOMER_ID;
    doc["organization"] = CUSTOMER_ORG;
    doc["status"] = "success";
    doc["timestamp"] = millis();
    
    String jsonString;
    serializeJson(doc, jsonString);
    request->send(200, "application/json", jsonString);
  });

  // Info endpoint  
  server.on("/info", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    JsonObject deviceObj = doc["device"].to<JsonObject>();
    deviceObj["type"] = "ESP32";
    deviceObj["mac_address"] = WiFi.macAddress();
    deviceObj["ap_ip"] = WiFi.softAPIP().toString();
    deviceObj["ap_ssid"] = AP_SSID;
    
    JsonObject customerObj = doc["customer"].to<JsonObject>();
    customerObj["organization"] = CUSTOMER_ORG;
    customerObj["customer_id"] = CUSTOMER_ID;
    customerObj["application"] = APPLICATION_NAME;
    
    String jsonString;
    serializeJson(doc, jsonString);
    request->send(200, "application/json", jsonString);
  });

  // Sensor endpoint - SHT30 I2C Temperature/Humidity 
  server.on("/sensor", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    
    if (!sensorAvailable) {
      // Sensor not available - return error response
      doc["success"] = false;
      doc["error"] = "SHT30 sensor not available";
      doc["error_details"] = sensorErrorMessage;
      doc["sensor"] = "SHT30";
      doc["mode"] = sensorMode;
      doc["sensor_available"] = false;
      doc["timestamp"] = millis();
      doc["customer_id"] = CUSTOMER_ID;
      doc["troubleshooting"] = "Check I2C connections, verify sensor power supply, ensure correct I2C address (0x44)";
      
      String jsonString;
      serializeJson(doc, jsonString);
      Serial.printf("ERROR: Sensor endpoint returning error - %s\n", sensorErrorMessage.c_str());
      request->send(500, "application/json", jsonString);
      return;
    }
    
    // Try to read from real sensor
    float temperature = sht31.readTemperature();
    float humidity = sht31.readHumidity();
    
    // Validate sensor readings
    if (isnan(temperature) || isnan(humidity) || 
        temperature <= -40 || temperature >= 80 || 
        humidity < 0 || humidity > 100) {
      
      // Sensor reading failed - return error
      doc["success"] = false;
      doc["error"] = "SHT30 sensor reading failed";
      doc["error_details"] = "Invalid sensor readings - temperature: " + String(temperature) + "Â°C, humidity: " + String(humidity) + "%";
      doc["sensor"] = "SHT30";
      doc["mode"] = "error";
      doc["sensor_available"] = true;
      doc["timestamp"] = millis();
      doc["customer_id"] = CUSTOMER_ID;
      doc["troubleshooting"] = "Sensor detected but readings invalid - check sensor condition and I2C communication";
      
      String jsonString;
      serializeJson(doc, jsonString);
      Serial.printf("ERROR: Sensor reading failed - Temp: %.2fÂ°C, Humidity: %.2f%%\n", temperature, humidity);
      request->send(500, "application/json", jsonString);
      return;
    }
    
    // Valid sensor data - return success response
    doc["success"] = true;
    doc["temp"] = round(temperature * 10) / 10.0; // Round to 1 decimal
    doc["humid"] = round(humidity * 10) / 10.0;   // Round to 1 decimal
    doc["sensor"] = "SHT30";
    doc["mode"] = "live";
    doc["sensor_available"] = true;
    doc["timestamp"] = millis();
    doc["customer_id"] = CUSTOMER_ID;
    
    String jsonString;
    serializeJson(doc, jsonString);
    Serial.printf("SUCCESS: Live sensor data - Temp: %.1fÂ°C, Humidity: %.1f%%RH\n", temperature, humidity);
    request->send(200, "application/json", jsonString);
  });

  // CU12 Check State endpoint (Medical Device)
  server.on("/check-state", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    
    if (!cu12Available) {
      // CU12 not available - return error response
      doc["success"] = false;
      doc["error"] = "CU12 hardware not available";
      doc["error_details"] = cu12ErrorMessage;
      doc["device"] = "CU12";
      doc["mode"] = cu12Mode;
      doc["cu12_available"] = false;
      doc["timestamp"] = millis();
      doc["customer_id"] = CUSTOMER_ID;
      doc["troubleshooting"] = "Check CU12 hardware connection, verify UART communication, ensure proper power supply";
      
      String jsonString;
      serializeJson(doc, jsonString);
      Serial.printf("ERROR: Check-state endpoint returning error - %s\n", cu12ErrorMessage.c_str());
      request->send(500, "application/json", jsonString);
      return;
    }
    
    // Send status request to CU12
    Serial.println("MEDICAL: Requesting CU12 slot status...");
    if (sendCU12Command(CU12_STATUS_REQUEST)) {
      uint8_t response[48];
      if (readCU12Response(response, sizeof(response))) {
        if (response[4] == CU12_ASK_SUCCESS) {
          // Parse slot states from response data
          uint8_t dataLen = response[5];
          JsonArray slotsArray = doc["slots"].to<JsonArray>();
          
          for (int i = 0; i < CU12_MAX_SLOTS; i++) {
            JsonObject slotObj = slotsArray.add<JsonObject>();
            slotObj["slot"] = i + 1;
            
            if (i < dataLen && dataLen > 0) {
              uint8_t slotState = response[8 + i]; // Data starts at position 8
              cu12SlotStates[i] = slotState;
              slotObj["state"] = slotState;
              slotObj["status"] = (slotState == 0) ? "locked" : "unlocked";
            } else {
              slotObj["state"] = 0;
              slotObj["status"] = "unknown";
            }
          }
          
          doc["success"] = true;
          doc["device"] = "CU12";
          doc["mode"] = "live";
          doc["cu12_available"] = true;
          doc["total_slots"] = CU12_MAX_SLOTS;
          doc["timestamp"] = millis();
          doc["customer_id"] = CUSTOMER_ID;
          doc["last_communication"] = lastCU12Communication;
          
          String jsonString;
          serializeJson(doc, jsonString);
          Serial.printf("SUCCESS: CU12 slot status retrieved - %d slots\n", CU12_MAX_SLOTS);
          request->send(200, "application/json", jsonString);
          return;
        }
      }
    }
    
    // Communication failed
    doc["success"] = false;
    doc["error"] = "CU12 communication failed";
    doc["error_details"] = "Failed to retrieve slot status from CU12 hardware";
    doc["device"] = "CU12";
    doc["mode"] = "error";
    doc["cu12_available"] = true;
    doc["timestamp"] = millis();
    doc["customer_id"] = CUSTOMER_ID;
    doc["troubleshooting"] = "Check CU12 hardware status, verify communication protocol, restart device if necessary";
    
    String jsonString;
    serializeJson(doc, jsonString);
    Serial.println("ERROR: CU12 status request failed");
    request->send(500, "application/json", jsonString);
  });

  // CU12 Unlock endpoint (Medical Device)
  server.on("/unlock", HTTP_POST, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    
    if (!cu12Available) {
      // CU12 not available - return error response
      doc["success"] = false;
      doc["error"] = "CU12 hardware not available";
      doc["error_details"] = cu12ErrorMessage;
      doc["device"] = "CU12";
      doc["mode"] = cu12Mode;
      doc["cu12_available"] = false;
      doc["timestamp"] = millis();
      doc["customer_id"] = CUSTOMER_ID;
      doc["troubleshooting"] = "Check CU12 hardware connection, verify UART communication, ensure proper power supply";
      
      String jsonString;
      serializeJson(doc, jsonString);
      Serial.printf("ERROR: Unlock endpoint returning error - %s\n", cu12ErrorMessage.c_str());
      request->send(500, "application/json", jsonString);
      return;
    }
    
    // Validate slot parameter
    int slotNumber = 0;
    if (request->hasParam("slot", true)) {
      slotNumber = request->getParam("slot", true)->value().toInt();
    } else if (request->hasParam("slot", false)) {
      slotNumber = request->getParam("slot", false)->value().toInt();
    } else {
      doc["success"] = false;
      doc["error"] = "Missing slot parameter";
      doc["error_details"] = "Slot number is required for unlock operation";
      doc["device"] = "CU12";
      doc["timestamp"] = millis();
      doc["customer_id"] = CUSTOMER_ID;
      doc["troubleshooting"] = "Provide slot parameter (1-12) in request body or query string";
      
      String jsonString;
      serializeJson(doc, jsonString);
      Serial.println("ERROR: Unlock request missing slot parameter");
      request->send(400, "application/json", jsonString);
      return;
    }
    
    // Validate slot range (Medical Device Safety)
    if (slotNumber < 1 || slotNumber > CU12_MAX_SLOTS) {
      doc["success"] = false;
      doc["error"] = "Invalid slot number";
      doc["error_details"] = "Slot number must be between 1 and " + String(CU12_MAX_SLOTS);
      doc["device"] = "CU12";
      doc["slot_requested"] = slotNumber;
      doc["valid_range"] = "1-" + String(CU12_MAX_SLOTS);
      doc["timestamp"] = millis();
      doc["customer_id"] = CUSTOMER_ID;
      doc["troubleshooting"] = "Verify slot number is within valid range for CU12 device";
      
      String jsonString;
      serializeJson(doc, jsonString);
      Serial.printf("ERROR: Invalid slot number requested - %d (valid: 1-%d)\n", slotNumber, CU12_MAX_SLOTS);
      request->send(400, "application/json", jsonString);
      return;
    }
    
    // Convert to 0-based index for CU12 protocol
    uint8_t lockNum = slotNumber - 1;
    
    // Send unlock command to CU12
    Serial.printf("MEDICAL: Unlocking CU12 slot %d (LOCKNUM: 0x%02X)...\n", slotNumber, lockNum);
    if (sendCU12Command(CU12_UNLOCK_SLOT, lockNum)) {
      uint8_t response[48];
      if (readCU12Response(response, sizeof(response))) {
        if (response[4] == CU12_ASK_SUCCESS) {
          // Update local slot state
          cu12SlotStates[lockNum] = 1; // 1 = unlocked
          
          doc["success"] = true;
          doc["message"] = "Slot unlocked successfully";
          doc["device"] = "CU12";
          doc["mode"] = "live";
          doc["cu12_available"] = true;
          doc["slot"] = slotNumber;
          doc["locknum"] = lockNum;
          doc["previous_state"] = cu12SlotStates[lockNum];
          doc["new_state"] = 1;
          doc["status"] = "unlocked";
          doc["timestamp"] = millis();
          doc["customer_id"] = CUSTOMER_ID;
          doc["last_communication"] = lastCU12Communication;
          
          String jsonString;
          serializeJson(doc, jsonString);
          Serial.printf("SUCCESS: CU12 slot %d unlocked successfully\n", slotNumber);
          request->send(200, "application/json", jsonString);
          return;
        } else {
          // CU12 returned error response
          String errorMsg = "CU12 unlock failed - ASK: 0x" + String(response[4], HEX);
          doc["success"] = false;
          doc["error"] = "CU12 unlock operation failed";
          doc["error_details"] = errorMsg;
          doc["device"] = "CU12";
          doc["slot"] = slotNumber;
          doc["locknum"] = lockNum;
          doc["ask_response"] = response[4];
          doc["timestamp"] = millis();
          doc["customer_id"] = CUSTOMER_ID;
          doc["troubleshooting"] = "Check slot mechanism, verify slot is not jammed, ensure proper CU12 operation";
          
          String jsonString;
          serializeJson(doc, jsonString);
          Serial.printf("ERROR: CU12 unlock failed - Slot: %d, ASK: 0x%02X\n", slotNumber, response[4]);
          request->send(500, "application/json", jsonString);
          return;
        }
      }
    }
    
    // Communication failed
    doc["success"] = false;
    doc["error"] = "CU12 communication failed";
    doc["error_details"] = "Failed to send unlock command to CU12 hardware";
    doc["device"] = "CU12";
    doc["mode"] = "error";
    doc["cu12_available"] = true;
    doc["slot"] = slotNumber;
    doc["locknum"] = lockNum;
    doc["timestamp"] = millis();
    doc["customer_id"] = CUSTOMER_ID;
    doc["troubleshooting"] = "Check CU12 hardware status, verify communication protocol, restart device if necessary";
    
    String jsonString;
    serializeJson(doc, jsonString);
    Serial.printf("ERROR: CU12 unlock communication failed - Slot: %d\n", slotNumber);
    request->send(500, "application/json", jsonString);
  });

  // Health endpoint
  server.on("/health", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    JsonObject serverObj = doc["server"].to<JsonObject>();
    serverObj["status"] = "healthy";
    serverObj["uptime_ms"] = millis();
    serverObj["connected_clients"] = WiFi.softAPgetStationNum();
    
    String jsonString;
    serializeJson(doc, jsonString);
    request->send(200, "application/json", jsonString);
  });

  // ========================================
  // MEDICAL DEVICE LOGGING ENDPOINT
  // ========================================
  server.on("/logs", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    
    // System information
    doc["success"] = true;
    doc["system"]["uptime_ms"] = millis();
    doc["system"]["free_heap"] = ESP.getFreeHeap();
    doc["system"]["total_logs"] = totalLogCount;
    doc["system"]["customer_id"] = CUSTOMER_ID;
    doc["system"]["timestamp"] = millis();
    
    // Hardware status
    JsonObject hardware = doc["hardware"].to<JsonObject>();
    hardware["cu12_available"] = cu12Available;
    hardware["cu12_mode"] = cu12Mode;
    hardware["cu12_error"] = cu12ErrorMessage;
    hardware["sensor_available"] = sensorAvailable;
    hardware["sensor_mode"] = sensorMode;
    hardware["sensor_error"] = sensorErrorMessage;
    
    // Network status
    JsonObject network = doc["network"].to<JsonObject>();
    network["wifi_mode"] = (WiFi.getMode() == WIFI_AP) ? "AP" : "STA";
    network["ap_ip"] = WiFi.softAPIP().toString();
    network["mac_address"] = WiFi.macAddress();
    network["connected_clients"] = WiFi.softAPgetStationNum();
    
    // Recent logs (last 20 entries)
    JsonArray logsArray = doc["logs"].to<JsonArray>();
    int entriesToShow = min(20, totalLogCount);
    int startIndex = (logIndex - entriesToShow + MAX_LOG_ENTRIES) % MAX_LOG_ENTRIES;
    
    for (int i = 0; i < entriesToShow; i++) {
      int idx = (startIndex + i) % MAX_LOG_ENTRIES;
      JsonObject logEntry = logsArray.add<JsonObject>();
      logEntry["timestamp"] = systemLogs[idx].timestamp;
      logEntry["level"] = systemLogs[idx].level;
      logEntry["component"] = systemLogs[idx].component;
      logEntry["message"] = systemLogs[idx].message;
      if (systemLogs[idx].details.length() > 0) {
        logEntry["details"] = systemLogs[idx].details;
      }
    }
    
    String jsonString;
    serializeJson(doc, jsonString);
    logNetworkEvent("INFO", "Logs endpoint accessed", "Returned " + String(entriesToShow) + " log entries");
    request->send(200, "application/json", jsonString);
  });

  // Detailed diagnostic endpoint
  server.on("/diagnostics", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    
    doc["success"] = true;
    doc["timestamp"] = millis();
    doc["customer_id"] = CUSTOMER_ID;
    
    // System diagnostics
    JsonObject system = doc["system"].to<JsonObject>();
    system["uptime_ms"] = millis();
    system["free_heap"] = ESP.getFreeHeap();
    system["heap_size"] = ESP.getHeapSize();
    system["chip_model"] = ESP.getChipModel();
    system["chip_revision"] = ESP.getChipRevision();
    system["cpu_freq_mhz"] = ESP.getCpuFreqMHz();
    
    // CU12 detailed diagnostics
    JsonObject cu12Diag = doc["cu12_diagnostics"].to<JsonObject>();
    cu12Diag["available"] = cu12Available;
    cu12Diag["mode"] = cu12Mode;
    cu12Diag["error_message"] = cu12ErrorMessage;
    cu12Diag["last_communication"] = lastCU12Communication;
    cu12Diag["rs485_de_pin"] = RS485_DE_PIN;
    cu12Diag["rs485_rx_pin"] = RS485_RX_PIN;
    cu12Diag["rs485_tx_pin"] = RS485_TX_PIN;
    cu12Diag["baud_rate"] = CU12_BAUD_RATE;
    cu12Diag["max_retries"] = CU12_MAX_RETRIES;
    
    // Sensor detailed diagnostics
    JsonObject sensorDiag = doc["sensor_diagnostics"].to<JsonObject>();
    sensorDiag["available"] = sensorAvailable;
    sensorDiag["mode"] = sensorMode;
    sensorDiag["error_message"] = sensorErrorMessage;
    if (sensorAvailable) {
      float temp = sht31.readTemperature();
      float hum = sht31.readHumidity();
      sensorDiag["current_temperature"] = temp;
      sensorDiag["current_humidity"] = hum;
      sensorDiag["temp_valid"] = !isnan(temp) && temp > -40 && temp < 85;
      sensorDiag["humidity_valid"] = !isnan(hum) && hum >= 0 && hum <= 100;
    }
    
    String jsonString;
    serializeJson(doc, jsonString);
    logNetworkEvent("INFO", "Diagnostics endpoint accessed", "Full system diagnostic report generated");
    request->send(200, "application/json", jsonString);
  });

  // Start server
  Serial.println("Starting HTTP server...");
  logSystemEvent("INFO", "Starting HTTP server with logging endpoints");
  server.begin();
  Serial.println("Server started successfully!");
  logSystemEvent("INFO", "HTTP server started successfully", "Ready for client connections");
  Serial.println("Ready for client connections.");
}

// Medical Device Compliance Functions
void logMedicalEvent(const String& event, const String& details, const String& severity = "INFO") {
  unsigned long timestamp = millis();
  Serial.printf("MEDICAL_LOG: [%s] %lu - %s: %s\n", 
                severity.c_str(), timestamp, event.c_str(), details.c_str());
}

void validateSystemHealth() {
  // Check WiFi status
  if (WiFi.status() != WL_CONNECTED && WiFi.getMode() != WIFI_AP) {
    logMedicalEvent("SYSTEM_HEALTH", "WiFi connection lost", "WARNING");
  }
  
  // Check CU12 communication health
  if (cu12Available && (millis() - lastCU12Communication > 60000)) { // 1 minute timeout
    logMedicalEvent("CU12_HEALTH", "CU12 communication timeout detected", "WARNING");
    cu12Available = false;
    cu12ErrorMessage = "Communication timeout - last contact: " + String(lastCU12Communication);
    cu12Mode = "timeout";
  }
  
  // Check sensor health
  if (sensorAvailable) {
    float temp = sht31.readTemperature();
    float hum = sht31.readHumidity();
    
    // Validate sensor readings for medical device compliance
    if (isnan(temp) || isnan(hum) || temp < -40 || temp > 85 || hum < 0 || hum > 100) {
      logMedicalEvent("SENSOR_HEALTH", "SHT30 readings out of range - T:" + String(temp) + "C H:" + String(hum) + "%", "ERROR");
      sensorAvailable = false;
      sensorErrorMessage = "Sensor readings validation failed";
      sensorMode = "error";
    }
  }
  
  // Memory health check
  size_t freeHeap = ESP.getFreeHeap();
  if (freeHeap < 10000) { // Less than 10KB free
    logMedicalEvent("MEMORY_HEALTH", "Low memory warning - Free: " + String(freeHeap) + " bytes", "WARNING");
  }
}

void performCU12HealthCheck() {
  if (!cu12Available) {
    return; // Skip if CU12 is not available
  }
  
  // Send version request to verify CU12 is still responsive
  Serial.println("MEDICAL: Performing CU12 health check...");
  if (sendCU12Command(CU12_GET_VERSION, 0x00)) {
    uint8_t response[48];
    if (readCU12Response(response, sizeof(response))) {
      if (response[4] == CU12_ASK_SUCCESS) {
        lastCU12Communication = millis();
        logMedicalEvent("CU12_HEALTH", "Health check passed", "INFO");
      } else {
        logMedicalEvent("CU12_HEALTH", "Health check failed - ASK: 0x" + String(response[4], HEX), "ERROR");
      }
    } else {
      logMedicalEvent("CU12_HEALTH", "Health check communication failed", "ERROR");
      cu12Available = false;
      cu12ErrorMessage = "Health check communication failure";
      cu12Mode = "error";
    }
  } else {
    logMedicalEvent("CU12_HEALTH", "Health check command send failed", "ERROR");
    cu12Available = false;
    cu12ErrorMessage = "Health check command failure";
    cu12Mode = "error";
  }
}

void loop() {
  // Periodic status reporting for medical device compliance
  static unsigned long lastStatusReport = 0;
  static unsigned long lastHealthCheck = 0;
  static unsigned long lastCU12HealthCheck = 0;
  
  unsigned long currentTime = millis();
  
  // System status report every 30 seconds
  if (currentTime - lastStatusReport > 30000) {
    Serial.printf("[%s] Status: %d clients, %d bytes free\n", 
                  CUSTOMER_ID, WiFi.softAPgetStationNum(), ESP.getFreeHeap());
    logMedicalEvent("SYSTEM_STATUS", "Periodic status report - Uptime: " + String(currentTime) + "ms", "INFO");
    lastStatusReport = currentTime;
  }
  
  // System health validation every 60 seconds
  if (currentTime - lastHealthCheck > 60000) {
    validateSystemHealth();
    lastHealthCheck = currentTime;
  }
  
  // CU12 health check every 5 minutes
  if (currentTime - lastCU12HealthCheck > 300000) {
    performCU12HealthCheck();
    lastCU12HealthCheck = currentTime;
  }
  
  // Handle any pending tasks
  delay(100); // Small delay for system stability
}